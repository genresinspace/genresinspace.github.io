<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Network Diagram</title>
    <!-- Fix React version to use 18 (latest stable) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background-color: black;
        height: 100%;
        color: white;
        overflow: hidden;
      }
      #app {
        height: 100vh;
        width: 100%;
        display: flex;
      }
      canvas {
        max-width: 100%;
        max-height: 100%;
      }
      /* Hide scrollbar for Chrome, Safari and Opera */
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      /* Hide scrollbar for IE, Edge and Firefox */
      .no-scrollbar {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
      }
    </style>
  </head>
  <body class="bg-black text-white">
    <div id="app"></div>

    <script type="text/babel">
      // Initial configuration
      const DEFAULT_CONFIG = {
        size: 1024,
        nodeCount: 8,
        minNodeRadius: 60,
        maxNodeRadius: 80,
        boundaryNodeCount: 5,
        boundaryNodeRadius: 0.93,
        boundaryNodeMaxRadius: 0.9,
        forceIterations: 300,
        movementThreshold: 0.325,
        outerRadius: 0.46,
        minInitialDistance: 0.37,
        layoutSeed: 46,
        nodeSeed: 32,
        nodeChroma: 0.31,
        nodeLightness: 0.81,
        angleWeight: 0.7,
        distanceWeight: 0.6,
        lineWidth: 40,
        outerLineWidth: 0,
      };

      // Left sidebar component for Node and Visual settings
      function LeftSidebar({ config, setConfig }) {
        // Group the config fields for UI display
        const configGroups = [
          {
            title: "Nodes",
            fields: [
              {
                key: "nodeCount",
                label: "Node Count",
                type: "number",
                min: 3,
                max: 100,
                step: 1,
              },
              {
                key: "minNodeRadius",
                label: "Min Node Radius",
                type: "number",
                min: 1,
                max: 100,
                step: 1,
              },
              {
                key: "maxNodeRadius",
                label: "Max Node Radius",
                type: "number",
                min: 1,
                max: 100,
                step: 1,
              },
              {
                key: "boundaryNodeCount",
                label: "Boundary Node Count",
                type: "number",
                min: 0,
                max: 50,
                step: 1,
              },
              {
                key: "boundaryNodeRadius",
                label: "Boundary Node Radius",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
              },
              {
                key: "boundaryNodeMaxRadius",
                label: "Boundary Node Max Radius",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
              },
            ],
          },
          {
            title: "Visual",
            fields: [
              {
                key: "nodeChroma",
                label: "Chroma (0-0.4)",
                type: "range",
                min: 0,
                max: 0.4,
                step: 0.01,
              },
              {
                key: "nodeLightness",
                label: "Lightness (0-1)",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
              },
              {
                key: "angleWeight",
                label: "Angle Weight (0-1)",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
              },
              {
                key: "distanceWeight",
                label: "Distance Weight (0-1)",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
              },
              {
                key: "lineWidth",
                label: "Line Width",
                type: "number",
                min: 0,
                max: 50,
                step: 0.5,
              },
              {
                key: "outerLineWidth",
                label: "Outer Line Width",
                type: "number",
                min: 0,
                max: 50,
                step: 0.5,
              },
            ],
          },
        ];

        const handleChange = (key, value) => {
          setConfig(key, value);
        };

        return (
          <div className="w-72 px-4 py-6 bg-gray-900 overflow-y-auto no-scrollbar">
            <h2 className="text-xl font-bold mb-4">Node Configuration</h2>

            <div className="space-y-4 mb-6">
              {configGroups.map((group) => (
                <div
                  key={group.title}
                  className="border border-gray-700 rounded-lg p-3"
                >
                  <h3 className="font-medium text-lg mb-2">{group.title}</h3>
                  <div className="space-y-3">
                    {group.fields.map((field) => (
                      <div key={field.key} className="flex flex-col">
                        <div className="flex justify-between">
                          <label className="text-sm">{field.label}</label>
                          {field.type !== "select" && (
                            <span className="text-sm text-gray-400">
                              {config[field.key]}
                            </span>
                          )}
                        </div>
                        {field.type === "range" ? (
                          <input
                            type="range"
                            min={field.min}
                            max={field.max}
                            step={field.step}
                            value={config[field.key]}
                            onChange={(e) =>
                              handleChange(field.key, e.target.value)
                            }
                            className="w-full accent-blue-500"
                          />
                        ) : field.type === "select" ? (
                          <select
                            value={config[field.key]}
                            onChange={(e) =>
                              handleChange(field.key, e.target.value)
                            }
                            className="w-full rounded bg-gray-800 border border-gray-700 px-2 py-1"
                          >
                            {field.options.map((option) => (
                              <option key={option.value} value={option.value}>
                                {option.label}
                              </option>
                            ))}
                          </select>
                        ) : (
                          <input
                            type={field.type}
                            min={field.min}
                            max={field.max}
                            step={field.step}
                            value={config[field.key]}
                            onChange={(e) =>
                              handleChange(field.key, e.target.value)
                            }
                            className="w-full rounded bg-gray-800 border border-gray-700 px-2 py-1"
                          />
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>

            <div className="space-y-2">
              <button
                onClick={() =>
                  navigator.clipboard.writeText(JSON.stringify(config, null, 2))
                }
                className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded"
              >
                Copy Config JSON
              </button>

              <button
                onClick={() => {
                  const canvas = document.querySelector("canvas");
                  if (canvas) {
                    // Convert canvas to data URL
                    const dataUrl = canvas.toDataURL("image/png");

                    // Create download link
                    const link = document.createElement("a");
                    link.download = "icon.png";
                    link.href = dataUrl;

                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                  }
                }}
                className="w-full bg-blue-700 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
              >
                Save as PNG
              </button>
            </div>
          </div>
        );
      }

      // Right sidebar component with Photoshop-style history panel
      function RightSidebar({
        config,
        setConfig,
        history,
        onUndo,
        onRedo,
        onNavigate,
      }) {
        // Group the config fields for UI display
        const configGroups = [
          {
            title: "Layout",
            fields: [
              {
                key: "forceIterations",
                label: "Force Iterations",
                type: "number",
                min: 10,
                max: 1000,
                step: 10,
              },
              {
                key: "movementThreshold",
                label: "Movement Threshold",
                type: "range",
                min: 0.001,
                max: 1,
                step: 0.001,
              },
              {
                key: "outerRadius",
                label: "Outer Radius",
                type: "range",
                min: 0.1,
                max: 0.99,
                step: 0.01,
              },
              {
                key: "minInitialDistance",
                label: "Min Initial Distance",
                type: "range",
                min: 0.05,
                max: 0.5,
                step: 0.01,
              },
            ],
          },
          {
            title: "Random Seeds",
            fields: [
              {
                key: "layoutSeed",
                label: "Layout Seed",
                type: "number",
                min: 0,
                max: 1000,
                step: 1,
              },
              {
                key: "nodeSeed",
                label: "Node Seed",
                type: "number",
                min: 0,
                max: 1000,
                step: 1,
              },
            ],
          },
        ];

        const handleChange = (key, value) => {
          // Convert string values to numbers where appropriate
          const numValue = !isNaN(parseFloat(value))
            ? parseFloat(value)
            : value;
          setConfig({ ...config, [key]: numValue });
        };

        return (
          <div className="w-72 px-4 py-6 bg-gray-900 overflow-y-auto no-scrollbar">
            <h2 className="text-xl font-bold mb-4">Layout Settings</h2>

            {/* Photoshop-style History Panel */}
            <div className="border border-gray-700 rounded-lg p-3 mb-4">
              <h3 className="font-medium text-lg mb-3">History</h3>

              {/* Undo/Redo buttons */}
              <div className="flex justify-between mb-3">
                <button
                  onClick={onUndo}
                  disabled={history.currentIndex < 0}
                  className={`flex items-center px-3 py-1.5 rounded transition-colors ${
                    history.currentIndex >= 0
                      ? "bg-blue-600 hover:bg-blue-700 text-white"
                      : "bg-gray-800 text-gray-500 cursor-not-allowed"
                  }`}
                  title={
                    history.currentIndex < 0
                      ? "No actions to undo"
                      : "Undo last action"
                  }
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-4 w-4 mr-1"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z"
                      clipRule="evenodd"
                    />
                  </svg>
                  Undo
                </button>
                <button
                  onClick={onRedo}
                  disabled={history.currentIndex >= history.commands.length - 1}
                  className={`flex items-center px-3 py-1.5 rounded transition-colors ${
                    history.currentIndex < history.commands.length - 1
                      ? "bg-blue-600 hover:bg-blue-700 text-white"
                      : "bg-gray-800 text-gray-500 cursor-not-allowed"
                  }`}
                  title={
                    history.currentIndex >= history.commands.length - 1
                      ? "No actions to redo"
                      : "Redo last undone action"
                  }
                >
                  Redo
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-4 w-4 ml-1"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z"
                      clipRule="evenodd"
                    />
                  </svg>
                </button>
              </div>

              {/* Always visible history list */}
              <div className="h-56 overflow-y-auto border border-gray-700 rounded bg-gray-950">
                {/* Command history - newest first */}
                {history.commands
                  .slice()
                  .reverse()
                  .map((command, reversedIndex) => {
                    const actualIndex =
                      history.commands.length - 1 - reversedIndex;
                    const isCurrentState = actualIndex === history.currentIndex;

                    return (
                      <div
                        key={`command-${actualIndex}`}
                        onClick={() => onNavigate(actualIndex)}
                        className={`p-2 border-b border-gray-800 hover:bg-gray-800 cursor-pointer text-sm flex items-center ${
                          isCurrentState
                            ? "bg-blue-900"
                            : actualIndex > history.currentIndex
                            ? "text-gray-400"
                            : ""
                        }`}
                        title={command.description}
                      >
                        <span className="w-5 text-center mr-2">
                          {isCurrentState && (
                            <span className="text-blue-400">●</span>
                          )}
                        </span>
                        <span>{command.name}</span>
                      </div>
                    );
                  })}

                {/* Initial state - at the bottom */}
                <div
                  className={`p-2 border-b border-gray-800 hover:bg-gray-800 cursor-pointer text-sm flex items-center ${
                    history.currentIndex === -1 ? "bg-blue-900" : ""
                  }`}
                  onClick={() => onNavigate(-1)}
                >
                  <span className="w-5 text-center mr-2">
                    {history.currentIndex === -1 && (
                      <span className="text-blue-400">●</span>
                    )}
                  </span>
                  <span>Initial State</span>
                </div>
              </div>
            </div>

            <div className="space-y-4">
              {configGroups.map((group) => (
                <div
                  key={group.title}
                  className="border border-gray-700 rounded-lg p-3"
                >
                  <h3 className="font-medium text-lg mb-2">{group.title}</h3>
                  <div className="space-y-3">
                    {group.fields.map((field) => (
                      <div key={field.key} className="flex flex-col">
                        <div className="flex justify-between">
                          <label className="text-sm">{field.label}</label>
                          <span className="text-sm text-gray-400">
                            {config[field.key]}
                          </span>
                        </div>
                        {field.type === "range" ? (
                          <input
                            type="range"
                            min={field.min}
                            max={field.max}
                            step={field.step}
                            value={config[field.key]}
                            onChange={(e) =>
                              handleChange(field.key, e.target.value)
                            }
                            className="w-full accent-blue-500"
                          />
                        ) : (
                          <input
                            type={field.type}
                            min={field.min}
                            max={field.max}
                            step={field.step}
                            value={config[field.key]}
                            onChange={(e) =>
                              handleChange(field.key, e.target.value)
                            }
                            className="w-full rounded bg-gray-800 border border-gray-700 px-2 py-1"
                          />
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      }

      // Main app component
      function App() {
        const [config, setConfig] = React.useState(DEFAULT_CONFIG);
        // Command pattern history implementation
        const [history, setHistory] = React.useState({
          commands: [], // All executed commands
          currentIndex: -1, // Current position in command history (-1 is initial state)
        });
        const [canvasUpdateCount, setCanvasUpdateCount] = React.useState(0);
        const canvasRef = React.useRef(null);
        const regenerateTimeoutRef = React.useRef(null);

        // Network generation utilities
        const createSeededRandom = (seed = 42) => {
          return () => {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
          };
        };

        // Generate stable color for a node based on its position and seed
        const generateStableColor = (node, config) => {
          // Convert to polar coordinates for better color distribution
          const centerX = config.size / 2;
          const centerY = config.size / 2;
          const dx = node.x - centerX;
          const dy = node.y - centerY;

          // Calculate angle (0-2π) and distance from center
          const angle = Math.atan2(dy, dx);
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Normalize angle to 0-1 range and add some distance influence
          const normalizedAngle = (angle + Math.PI) / (2 * Math.PI); // Convert from -π,π to 0,1
          const normalizedDistance = (distance / (config.size * 0.5)) % 1.0; // Normalize distance

          // Combine angle and distance to create unique hue
          // This ensures nodes at different angles and distances get different colors
          const hue =
            (normalizedAngle * config.angleWeight +
              normalizedDistance * config.distanceWeight) %
            1.0;

          return `oklch(${config.nodeLightness} ${config.nodeChroma} ${
            hue * 360
          })`;
        };

        // Calculate distance between two points
        const distance = (p1, p2) => {
          return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        };

        // Check if two edges are the same (regardless of direction)
        const edgesEqual = (edge1, edge2) => {
          return (
            (edge1[0].id === edge2[0].id && edge1[1].id === edge2[1].id) ||
            (edge1[0].id === edge2[1].id && edge1[1].id === edge2[0].id)
          );
        };

        // Check if a point is inside the circumcircle of a triangle
        const circumCircleContains = (triangle, point) => {
          const vertices = triangle.vertices;

          // Calculate the circumcenter
          const a = vertices[0];
          const b = vertices[1];
          const c = vertices[2];

          const D =
            2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));

          if (Math.abs(D) < 1e-10) return false;

          const ux =
            ((a.x * a.x + a.y * a.y) * (b.y - c.y) +
              (b.x * b.x + b.y * b.y) * (c.y - a.y) +
              (c.x * c.x + c.y * c.y) * (a.y - b.y)) /
            D;

          const uy =
            ((a.x * a.x + a.y * a.y) * (c.x - b.x) +
              (b.x * b.x + b.y * b.y) * (a.x - c.x) +
              (c.x * c.x + c.y * c.y) * (b.x - a.x)) /
            D;

          const center = { x: ux, y: uy };
          const radius = distance(center, a);

          return distance(center, point) <= radius;
        };

        // Improved force-directed placement to evenly distribute nodes
        const applyForces = (nodes, iterations = config.forceIterations) => {
          const centerX = config.size / 2;
          const centerY = config.size / 2;
          const outerRadiusPx = config.size * config.outerRadius;

          const random = createSeededRandom(config.layoutSeed);

          // Calculate desired distance between nodes
          const circleArea =
            Math.PI *
            (outerRadiusPx * config.boundaryNodeMaxRadius) *
            (outerRadiusPx * config.boundaryNodeMaxRadius);
          const desiredDistance = Math.sqrt(circleArea / nodes.length) * 1.2;

          // Track node movements to detect equilibrium
          const movementThreshold = config.movementThreshold;
          let equilibriumCount = 0;

          for (let iter = 0; iter < iterations; iter++) {
            let totalMovement = 0;

            // Apply forces to each node
            for (let i = 0; i < nodes.length; i++) {
              let fx = 0,
                fy = 0;

              // Repulsion from other nodes
              for (let j = 0; j < nodes.length; j++) {
                if (i === j) continue;

                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                const d = Math.sqrt(dx * dx + dy * dy);

                if (d < 1e-6) {
                  // Add random offset to avoid division by zero
                  fx += random() * 2 - 1;
                  fy += random() * 2 - 1;
                  continue;
                }

                // Stronger repulsion at close distances, weaker at far distances
                let repulsionStrength;
                if (d < desiredDistance * 0.5) {
                  repulsionStrength = (desiredDistance * 10) / d;
                } else if (d < desiredDistance) {
                  repulsionStrength = (desiredDistance * 2) / d;
                } else {
                  repulsionStrength = desiredDistance / d;
                }

                fx += (dx / d) * repulsionStrength;
                fy += (dy / d) * repulsionStrength;
              }

              // Center attraction to avoid nodes drifting too far
              const distFromCenter = Math.sqrt(
                (nodes[i].x - centerX) ** 2 + (nodes[i].y - centerY) ** 2
              );

              const centerAttractionStrength =
                0.03 * Math.max(0, distFromCenter - outerRadiusPx * 0.5);
              fx -=
                ((nodes[i].x - centerX) * centerAttractionStrength) /
                distFromCenter;
              fy -=
                ((nodes[i].y - centerY) * centerAttractionStrength) /
                distFromCenter;

              // Boundary force (stronger when close to boundary)
              if (distFromCenter > outerRadiusPx * 0.75) {
                const boundaryForce =
                  Math.pow(
                    distFromCenter /
                      (outerRadiusPx * config.boundaryNodeMaxRadius),
                    4
                  ) * 5;
                const angle = Math.atan2(
                  nodes[i].y - centerY,
                  nodes[i].x - centerX
                );

                fx -= Math.cos(angle) * boundaryForce;
                fy -= Math.sin(angle) * boundaryForce;
              }

              // Add small random jitter to avoid local minima
              if (iter < iterations * 0.7) {
                const jitterStrength = 0.1 * (1 - iter / iterations);
                fx += (random() * 2 - 1) * jitterStrength;
                fy += (random() * 2 - 1) * jitterStrength;
              }

              // Damping factor decreases over time
              const dampingFactor = 0.1 * Math.pow(0.9, iter / 20);

              // Calculate movement
              const dx = fx * dampingFactor;
              const dy = fy * dampingFactor;

              // Update position
              nodes[i].x += dx;
              nodes[i].y += dy;

              // Track movement
              totalMovement += Math.abs(dx) + Math.abs(dy);
            }

            // Check for equilibrium
            if (totalMovement / nodes.length < movementThreshold) {
              equilibriumCount++;
              if (equilibriumCount > 5) {
                console.log(`Equilibrium reached at iteration ${iter}`);
                break;
              }
            } else {
              equilibriumCount = 0;
            }

            // Ensure all nodes stay within the circle
            for (let i = 0; i < nodes.length; i++) {
              const distFromCenter = Math.sqrt(
                (nodes[i].x - centerX) ** 2 + (nodes[i].y - centerY) ** 2
              );

              if (
                distFromCenter >
                outerRadiusPx * config.boundaryNodeMaxRadius
              ) {
                const angle = Math.atan2(
                  nodes[i].y - centerY,
                  nodes[i].x - centerX
                );
                nodes[i].x =
                  centerX +
                  outerRadiusPx *
                    config.boundaryNodeMaxRadius *
                    Math.cos(angle);
                nodes[i].y =
                  centerY +
                  outerRadiusPx *
                    config.boundaryNodeMaxRadius *
                    Math.sin(angle);
              }
            }
          }

          return nodes;
        };

        // Delaunay triangulation using Bowyer-Watson algorithm
        const computeDelaunay = (points) => {
          // Find the super triangle
          let minX = points[0].x;
          let minY = points[0].y;
          let maxX = minX;
          let maxY = minY;

          for (let i = 1; i < points.length; i++) {
            if (points[i].x < minX) minX = points[i].x;
            if (points[i].y < minY) minY = points[i].y;
            if (points[i].x > maxX) maxX = points[i].x;
            if (points[i].y > maxY) maxY = points[i].y;
          }

          const dx = maxX - minX;
          const dy = maxY - minY;
          const dmax = Math.max(dx, dy);
          const midX = (minX + maxX) / 2;
          const midY = (minY + maxY) / 2;

          // Create a super triangle that contains all points
          const p1 = { x: midX - 20 * dmax, y: midY - dmax, id: -1 };
          const p2 = { x: midX, y: midY + 20 * dmax, id: -2 };
          const p3 = { x: midX + 20 * dmax, y: midY - dmax, id: -3 };

          // Initialize triangulation with the super triangle
          let triangulation = [{ vertices: [p1, p2, p3] }];

          // Add points one by one
          for (const point of points) {
            // Find all triangles whose circumcircle contains the point
            const badTriangles = [];

            for (const triangle of triangulation) {
              if (circumCircleContains(triangle, point)) {
                badTriangles.push(triangle);
              }
            }

            // Find the boundary of the polygonal hole
            const polygon = [];

            for (const triangle of badTriangles) {
              // Check each edge of the triangle
              for (let i = 0; i < 3; i++) {
                const edge = [
                  triangle.vertices[i],
                  triangle.vertices[(i + 1) % 3],
                ];

                // Check if the edge is not shared by any other bad triangle
                let shared = false;

                for (const otherTriangle of badTriangles) {
                  if (triangle === otherTriangle) continue;

                  // Check if otherTriangle contains this edge
                  for (let j = 0; j < 3; j++) {
                    const otherEdge = [
                      otherTriangle.vertices[j],
                      otherTriangle.vertices[(j + 1) % 3],
                    ];
                    if (edgesEqual(edge, otherEdge)) {
                      shared = true;
                      break;
                    }
                  }

                  if (shared) break;
                }

                if (!shared) {
                  polygon.push(edge);
                }
              }
            }

            // Remove bad triangles
            triangulation = triangulation.filter(
              (triangle) => !badTriangles.includes(triangle)
            );

            // Re-triangulate the polygonal hole
            for (const edge of polygon) {
              triangulation.push({ vertices: [edge[0], edge[1], point] });
            }
          }

          // Remove triangles that use vertices of the super triangle
          triangulation = triangulation.filter((triangle) => {
            return !triangle.vertices.some((v) => v.id < 0);
          });

          return triangulation;
        };

        // Extract edges from triangulation
        const extractEdges = (triangulation) => {
          const edges = new Set();

          for (const triangle of triangulation) {
            const vertices = triangle.vertices;

            for (let i = 0; i < 3; i++) {
              const a = vertices[i].id;
              const b = vertices[(i + 1) % 3].id;

              if (a < 0 || b < 0) continue; // Skip edges from super triangle

              // Ensure consistent edge representation
              const edgeKey = a < b ? `${a}-${b}` : `${b}-${a}`;
              edges.add(edgeKey);
            }
          }

          return Array.from(edges).map((key) => {
            const [a, b] = key.split("-").map(Number);
            return { source: a, target: b };
          });
        };

        // Main drawing function
        const drawNetworkDiagram = () => {
          if (!canvasRef.current) return;

          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          const centerX = config.size / 2;
          const centerY = config.size / 2;
          const outerRadiusPx = config.size * config.outerRadius;
          const minInitialDistancePx =
            outerRadiusPx * config.minInitialDistance;

          const random = createSeededRandom(config.nodeSeed);

          // Clear canvas with transparency
          ctx.clearRect(0, 0, config.size, config.size);

          // Draw outer circle
          if (config.outerLineWidth > 0) {
            ctx.strokeStyle = "white";
            ctx.lineWidth = config.outerLineWidth;
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadiusPx, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Generate random node radius function
          const nodeRadius = () =>
            config.minNodeRadius +
            (config.maxNodeRadius - config.minNodeRadius) * random();

          // Generate initial nodes with blue noise distribution
          const nodes = [];
          const minInitialDistance = minInitialDistancePx;

          // First, create nodes at regular intervals around the boundary
          const boundaryNodeCount = config.boundaryNodeCount;
          for (let i = 0; i < boundaryNodeCount; i++) {
            const angle = (i / boundaryNodeCount) * Math.PI * 2;
            nodes.push({
              x:
                centerX +
                outerRadiusPx * config.boundaryNodeRadius * Math.cos(angle),
              y:
                centerY +
                outerRadiusPx * config.boundaryNodeRadius * Math.sin(angle),
              radius: nodeRadius(),
              id: i,
            });
          }

          // Then fill the interior with a blue noise-like distribution
          for (
            let i = boundaryNodeCount;
            i < config.nodeCount && nodes.length < config.nodeCount;
            i++
          ) {
            let attempts = 0;
            let validPosition = false;
            let newNode;

            while (!validPosition && attempts < 100) {
              const r = outerRadiusPx * 0.75 * Math.sqrt(random()); // sqrt for uniform distribution
              const angle = random() * 2 * Math.PI;
              const x = centerX + r * Math.cos(angle);
              const y = centerY + r * Math.sin(angle);

              newNode = { x, y, radius: nodeRadius(), id: nodes.length };

              // Check minimum distance from other nodes
              validPosition = true;
              for (const node of nodes) {
                if (distance(newNode, node) < minInitialDistance) {
                  validPosition = false;
                  break;
                }
              }

              attempts++;
            }

            if (validPosition) {
              nodes.push(newNode);
            }
          }

          // Apply force-directed algorithm to distribute nodes evenly
          applyForces(nodes);

          // Compute Delaunay triangulation
          const triangulation = computeDelaunay(nodes);

          // Extract edges from triangulation
          const links = extractEdges(triangulation);

          // Assign colors to nodes
          nodes.forEach((node, index) => {
            node.color = generateStableColor(node, config);
          });

          // Draw links
          ctx.strokeStyle = "white";
          ctx.lineWidth = config.lineWidth;

          links.forEach((link) => {
            const sourceNode = nodes[link.source];
            const targetNode = nodes[link.target];

            ctx.beginPath();
            ctx.moveTo(sourceNode.x, sourceNode.y);
            ctx.lineTo(targetNode.x, targetNode.y);
            ctx.stroke();
          });

          // Draw nodes
          nodes.forEach((node) => {
            ctx.fillStyle = node.color;
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
            ctx.fill();
          });

          // Increment canvas update count to refresh previews
          setCanvasUpdateCount((prev) => prev + 1);
        };

        // Schedule regeneration after config changes
        const scheduleRegeneration = () => {
          // Clear any existing timeout
          if (regenerateTimeoutRef.current) {
            clearTimeout(regenerateTimeoutRef.current);
          }

          // Set new timeout
          regenerateTimeoutRef.current = setTimeout(() => {
            drawNetworkDiagram();
          }, 250); // 250ms delay before regenerating
        };

        // Debounced config update for all inputs
        const debouncedConfigUpdate = React.useRef({});
        const debounceTimeoutRef = React.useRef(null);

        const handleDebouncedChange = (key, value) => {
          // Store the change in the debounced update object
          debouncedConfigUpdate.current[key] = value;

          // Clear any existing debounce timeout
          if (debounceTimeoutRef.current) {
            clearTimeout(debounceTimeoutRef.current);
          }

          // Set new debounce timeout
          debounceTimeoutRef.current = setTimeout(() => {
            // Apply all accumulated changes at once
            const changes = debouncedConfigUpdate.current;
            if (Object.keys(changes).length > 0) {
              const newConfig = { ...config, ...changes };
              handleConfigUpdate(newConfig);
              debouncedConfigUpdate.current = {};
            }
          }, 200); // 200ms debounce delay
        };

        // Unified handler for all config changes
        const handleConfigChange = (key, value) => {
          const numValue = !isNaN(parseFloat(value))
            ? parseFloat(value)
            : value;
          // Update the display value immediately for responsive UI
          setConfig((prev) => ({ ...prev, [key]: numValue }));
          // Also queue it for debounced processing
          handleDebouncedChange(key, value);
        };

        // Create a new command and execute it
        const executeCommand = (key, newValue) => {
          const oldValue = config[key];

          // Don't create a command if value didn't change
          if (oldValue === newValue) return;

          // Create a command object
          const command = {
            name: `${key}: ${oldValue} → ${newValue}`,
            execute: () => {
              const newConfig = { ...config };
              newConfig[key] = newValue;
              setConfig(newConfig);
            },
            undo: () => {
              const prevConfig = { ...config };
              prevConfig[key] = oldValue;
              setConfig(prevConfig);
            },
            description: `Changed ${key} from ${oldValue} to ${newValue}`,
          };

          // Execute the command
          command.execute();

          // Add to history, removing any future commands if we're not at the end
          const newCommands = history.commands.slice(
            0,
            history.currentIndex + 1
          );
          newCommands.push(command);

          setHistory({
            commands: newCommands,
            currentIndex: newCommands.length - 1,
          });
        };

        // Update config handler that creates and executes commands
        const handleConfigUpdate = (newConfig) => {
          // Find what changed compared to current config
          const changedKey = Object.keys(newConfig).find(
            (key) => newConfig[key] !== config[key]
          );

          // Execute a command for the change
          if (changedKey) {
            executeCommand(changedKey, newConfig[changedKey]);
            scheduleRegeneration();
          }
        };

        // Undo the last command
        const handleUndo = () => {
          if (history.currentIndex >= 0) {
            // Get the command to undo
            const command = history.commands[history.currentIndex];

            // Run the undo function
            command.undo();

            // Update history position
            setHistory({
              ...history,
              currentIndex: history.currentIndex - 1,
            });

            scheduleRegeneration();
          }
        };

        // Redo the next command
        const handleRedo = () => {
          if (history.currentIndex < history.commands.length - 1) {
            // Move to next command
            const nextIndex = history.currentIndex + 1;
            const command = history.commands[nextIndex];

            // Execute the command
            command.execute();

            // Update history position
            setHistory({
              ...history,
              currentIndex: nextIndex,
            });

            scheduleRegeneration();
          }
        };

        // Navigate to a specific point in history
        const navigateToHistoryState = (index) => {
          if (index === history.currentIndex) return; // Already at this state

          // Going to initial state (before any commands)
          if (index === -1) {
            setConfig(DEFAULT_CONFIG);
            setHistory({
              ...history,
              currentIndex: -1,
            });
            scheduleRegeneration();
            return;
          }

          // If going backwards
          if (index < history.currentIndex) {
            // Undo commands one by one from current to target
            for (let i = history.currentIndex; i > index; i--) {
              history.commands[i].undo();
            }
          }
          // If going forwards
          else {
            // Execute commands one by one from current to target
            for (let i = history.currentIndex + 1; i <= index; i++) {
              history.commands[i].execute();
            }
          }

          // Update history position
          setHistory({
            ...history,
            currentIndex: index,
          });

          scheduleRegeneration();
        };

        // Draw the network diagram when the component mounts and when config changes
        React.useEffect(() => {
          // Set the canvas width and height
          if (canvasRef.current) {
            canvasRef.current.width = config.size;
            canvasRef.current.height = config.size;
            drawNetworkDiagram();
          }

          // Clean up any pending timers when component unmounts
          return () => {
            if (regenerateTimeoutRef.current) {
              clearTimeout(regenerateTimeoutRef.current);
            }
            if (debounceTimeoutRef.current) {
              clearTimeout(debounceTimeoutRef.current);
            }
          };
        }, []); // Only run on mount

        // Schedule regeneration whenever config changes
        React.useEffect(() => {
          scheduleRegeneration();
        }, [config]); // Run whenever config changes

        return (
          <div className="flex flex-row w-full h-full">
            <LeftSidebar config={config} setConfig={handleConfigChange} />

            <div className="flex-grow flex flex-col items-center justify-center bg-gray-800 p-4 h-full">
              <canvas
                ref={canvasRef}
                width={config.size}
                height={config.size}
                className="max-w-full max-h-[calc(100vh-8rem)] object-contain mb-4"
              />

              {/* Icon Size Previews */}
              <div className="bg-gray-900 rounded-lg p-4 w-full max-w-2xl">
                <h3 className="text-lg font-semibold mb-3 text-center">
                  Icon Size Previews
                </h3>
                <div className="grid grid-cols-4 gap-4">
                  {[16, 32, 64, 128].map((size) => (
                    <div
                      key={`${size}-${canvasUpdateCount}`}
                      className="flex flex-col items-center"
                    >
                      <div className="text-sm text-gray-400 mb-2">
                        {size}×{size}
                      </div>
                      <div
                        className="border border-gray-600 rounded bg-gray-800"
                        style={{
                          width: `${size}px`,
                          height: `${size}px`,
                          backgroundImage: `url(${
                            canvasRef.current
                              ? canvasRef.current.toDataURL()
                              : ""
                          })`,
                          backgroundSize: "cover",
                          backgroundPosition: "center",
                          imageRendering: "pixelated",
                        }}
                      />
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <RightSidebar
              config={config}
              setConfig={handleConfigUpdate}
              history={history}
              onUndo={handleUndo}
              onRedo={handleRedo}
              onNavigate={navigateToHistoryState}
            />
          </div>
        );
      }

      // Render the React app - use the correct ReactDOM method for React 18
      const root = ReactDOM.createRoot(document.getElementById("app"));
      root.render(<App />);
    </script>
  </body>
</html>
